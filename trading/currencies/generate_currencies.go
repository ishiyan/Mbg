// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates `currencies.go` and `currencies_test.go`, overwriting any existing versions.
// It should be invoked by running `go generate` in this directory.
// It reads currency data from the `currencies.csv` file.

package main

import (
	"bytes"
	"encoding/csv"
	"errors"
	"fmt"
	"go/format"
	"io"
	"os"
	"strconv"
	"strings"
	"time"
)

type currency struct {
	code        string
	decimals    int
	symbol      string
	description string
}

var errInvalidLine = errors.New("invalid input CSV line")

func main() {
	cs, err := read("currencies.csv")
	if err != nil {
		die(err)
	}

	printCurrencyGo("currencies.go", cs)
	printCurrencyTestGo("currencies_test.go", cs)
}

func read(filename string) ([]currency, error) {
	currencies := []currency{}

	f, err := os.Open(filename)
	if err != nil {
		return currencies, fmt.Errorf("opening currencies: %w", err)
	}
	defer f.Close()

	r := csv.NewReader(f)
	r.Comma = '|'
	r.Comment = '#'
	r.FieldsPerRecord = 4
	r.ReuseRecord = false
	r.TrimLeadingSpace = true

	ln := 0

	for {
		record, err := r.Read()
		if errors.Is(err, io.EOF) {
			break
		}

		ln++
		if err != nil {
			return currencies, fmt.Errorf("line %v: error reading: %w", ln, err)
		}

		c, err := parse(record, ln)
		if err != nil {
			return currencies, err
		}

		currencies = append(currencies, *c)
	}

	return currencies, nil
}

func parse(record []string, ln int) (*currency, error) {
	code := strings.TrimSpace(record[0])
	if len(code) != 3 { //nolint:gomnd
		return nil, fmt.Errorf(
			"line %v: currency code should have 3 characters, got '%v': %w", ln, code, errInvalidLine)
	}

	d := strings.TrimSpace(record[1])
	if len(d) < 1 {
		return nil, fmt.Errorf(
			"line %v: number of decimals should not be empty, got '%v': %w", ln, d, errInvalidLine)
	}

	dec, err := strconv.Atoi(d)
	if err != nil {
		return nil, fmt.Errorf(
			"line %v: number of decimals should be an integer, got '%v': %w", ln, d, errInvalidLine)
	}

	if dec < 0 {
		return nil, fmt.Errorf(
			"line %v: number of decimals should be a positive integer, got '%v': %w", ln, d, errInvalidLine)
	}

	symbol := strings.TrimSpace(record[2])
	descr := strings.TrimSpace(record[3])

	if len(descr) < 1 {
		return nil, fmt.Errorf("line %v: description should not be empty: %w", ln, errInvalidLine)
	}

	return &currency{code, dec, symbol, descr}, nil
}

func die(err error) {
	fmt.Println(err) //nolint:forbidigo
	os.Exit(1)
}

func printf(w io.Writer, format string, a ...interface{}) {
	_, err := fmt.Fprintf(w, format, a...)
	if err != nil {
		die(err)
	}
}

func minmaxdecimals(cs []currency) (int, int) {
	min := 999
	max := -999 //nolint:gomnd

	for _, c := range cs {
		if c.decimals > max {
			max = c.decimals
		}

		if c.decimals < min {
			min = c.decimals
		}
	}

	return min, max
}

func codes(cs []currency, n int) string {
	first := true
	s := ""

	for _, c := range cs {
		if c.decimals == n {
			if first {
				first = false
			} else {
				s += ", "
			}

			s += c.code
		}
	}

	return s
}

func printBuffer(b *bytes.Buffer, filename string, formatSource bool) {
	f, err := os.Create(filename)
	if err != nil {
		die(err)
	}
	defer f.Close()

	if formatSource {
		data, err := format.Source(b.Bytes())
		if err != nil {
			die(err)
		}

		_, err = f.Write(data)
		if err != nil {
			die(err)
		}
	} else {
		_, err = f.Write(b.Bytes())
		if err != nil {
			die(err)
		}
	}
}

//nolint:funlen,cyclop
func printCurrencyGo(filename string, cs []currency) {
	var b bytes.Buffer

	printf(&b, "// Code generated by 'go generate'; DO NOT EDIT.\n")
	printf(&b, "// %v\n\n", time.Now())

	printf(&b, "// Package currencies provides a set of predefined ISO 4217\n")
	printf(&b, "// three-letter alphabetic currency codes generated from data from\n")
	printf(&b, "// https://www.currency-iso.org/en/home/tables/table-a1.html.\n")
	printf(&b, "package currencies\n\n")

	printf(&b, "import \"fmt\"\n\n")

	printf(&b, "// Currency is an ISO 4217 three-letter alphabetic code for the representation of currencies.\n")
	printf(&b, "type Currency string\n\n")

	printf(&b, "//nolint:lll\n")
	printf(&b, "const (\n")

	for _, c := range cs {
		printf(&b, "\t%v = Currency(\"%v\") // %v\n", c.code, c.code, c.description)
	}

	printf(&b, ")\n\n")

	printf(&b, "//gocyclo:ignore\n")
	printf(&b, "//nolint:funlen,cyclop,exhaustive\n")
	printf(&b, "// Symbol returns a currency symbol to display.\n")
	printf(&b, "func (c Currency) Symbol() string {\n")
	printf(&b, "\tswitch c {\n")

	for _, c := range cs {
		if len(c.symbol) > 0 {
			printf(&b, "\tcase %v:\n", c.code)
			printf(&b, "\t\treturn \"%v\"\n", c.symbol)
		}
	}

	printf(&b, "\tdefault:\n")
	printf(&b, "\t\treturn \"\"\n")
	printf(&b, "\t}\n")
	printf(&b, "}\n\n")

	printf(&b, "//nolint:gomnd,exhaustive\n")
	printf(&b, "// Decimals returns the number of minor units (digits after the decimal separator).\n")
	printf(&b, "func (c Currency) Decimals() int {\n")
	printf(&b, "\tswitch c {\n")

	min, max := minmaxdecimals(cs)
	for i := min; i <= max; i++ {
		s := codes(cs, i)
		if i != 2 && len(s) > 0 {
			printf(&b, "\tcase %v:\n", s)
			printf(&b, "\t\treturn %v\n", i)
		}
	}

	printf(&b, "\tdefault:\n")
	printf(&b, "\t\treturn 2\n")
	printf(&b, "\t}\n")
	printf(&b, "}\n\n")

	printf(&b, "//nolint:exhaustive\n")
	printf(&b, "// RoundString returns string representing an amount rounded to the number of minor units\n")
	printf(&b, "// (digits after the decimal separator).\n")
	printf(&b, "func (c Currency) RoundString(amount float64) string {\n")
	printf(&b, "\tswitch c {\n")

	for i := min; i <= max; i++ {
		s := codes(cs, i)
		if i != 2 && len(s) > 0 {
			j := i
			if j > 16 { //nolint:gomnd
				j = 16 // Float64 can have maximum 16 decimal digits
			}

			printf(&b, "\tcase %v:\n", s)
			printf(&b, "\t\treturn fmt.Sprintf(\"%%.%vf\", amount) // %v decimals\n", j, i)
		}
	}

	printf(&b, "\tdefault:\n")
	printf(&b, "\t\treturn fmt.Sprintf(\"%%.2f\", amount)\n")
	printf(&b, "\t}\n")
	printf(&b, "}\n")

	printBuffer(&b, filename, true)
}

//nolint:funlen
func printCurrencyTestGo(filename string, cs []currency) {
	var b bytes.Buffer

	printf(&b, "// Code generated by 'go generate'; DO NOT EDIT.\n")
	printf(&b, "// %v\n\n", time.Now())

	printf(&b, "//nolint:testpackage\n")
	printf(&b, "package currencies\n\n")

	printf(&b, "import \"testing\"\n\n")

	printf(&b, "//nolint:dupl,funlen\n")
	printf(&b, "func TestSymbol(t *testing.T) {\n")
	printf(&b, "\tt.Parallel()\n\n")
	printf(&b, "\ttests := []struct {\n")
	printf(&b, "\t\tcur Currency\n")
	printf(&b, "\t\tsym string\n")
	printf(&b, "\t}{\n")

	for _, c := range cs {
		printf(&b, "\t\t{%v, \"%v\"},\n", c.code, c.symbol)
	}

	printf(&b, "\t}\n\n")
	printf(&b, "\tfor _, tt := range tests {\n")
	printf(&b, "\t\texp := tt.sym\n")
	printf(&b, "\t\tact := tt.cur.Symbol()\n\n")
	printf(&b, "\t\tif exp != act {\n")
	printf(&b, "\t\t\tt.Errorf(\"%%v.Symbol(): expected '%%v', actual '%%v'\", tt.cur, exp, act)\n")
	printf(&b, "\t\t}\n")
	printf(&b, "\t}\n")
	printf(&b, "}\n\n")

	printf(&b, "//nolint:dupl,funlen\n")
	printf(&b, "func TestDecimals(t *testing.T) {\n")
	printf(&b, "\tt.Parallel()\n\n")
	printf(&b, "\ttests := []struct {\n")
	printf(&b, "\t\tcur Currency\n")
	printf(&b, "\t\tdec int\n")
	printf(&b, "\t}{\n")

	for _, c := range cs {
		printf(&b, "\t\t{%v, %v},\n", c.code, c.decimals)
	}

	printf(&b, "\t}\n\n")
	printf(&b, "\tfor _, tt := range tests {\n")
	printf(&b, "\t\texp := tt.dec\n")
	printf(&b, "\t\tact := tt.cur.Decimals()\n\n")
	printf(&b, "\t\tif exp != act {\n")
	printf(&b, "\t\t\tt.Errorf(\"%%v.Decimals(): expected '%%v', actual '%%v'\", tt.cur, exp, act)\n")
	printf(&b, "\t\t}\n")
	printf(&b, "\t}\n")
	printf(&b, "}\n\n")

	printf(&b, "//nolint:funlen\n")
	printf(&b, "func TestRoundString(t *testing.T) {\n")
	printf(&b, "\tt.Parallel()\n\n")
	printf(&b, "\ttests := []struct {\n")
	printf(&b, "\t\tcur Currency\n")
	printf(&b, "\t\tnum float64\n")
	printf(&b, "\t\tstr string\n")
	printf(&b, "\t}{\n")

	for _, c := range cs {
		n, s := testdata(c)
		printf(&b, "\t\t{%v, %v, \"%v\"},\n", c.code, n, s)
	}

	printf(&b, "\t}\n\n")
	printf(&b, "\tfor _, tt := range tests {\n")
	printf(&b, "\t\texp := tt.str\n")
	printf(&b, "\t\tact := tt.cur.RoundString(tt.num)\n\n")
	printf(&b, "\t\tif exp != act {\n")
	printf(&b, "\t\t\tt.Errorf(\"%%v.RoundString(%%v): expected '%%v', actual '%%v'\", tt.cur, tt.num, exp, act)\n")
	printf(&b, "\t\t}\n")
	printf(&b, "\t}\n")
	printf(&b, "}\n")

	printBuffer(&b, filename, true)
}

//nolint:gomnd,cyclop
func testdata(c currency) (float64, string) {
	switch c.decimals {
	case 0:
		return 123.9, "124"
	case 1:
		return 123.09, "123.1"
	case 2:
		return 123.009, "123.01"
	case 3:
		return 123.0009, "123.001"
	case 4:
		return 123.00009, "123.0001"
	case 5:
		return 123.000009, "123.00001"
	case 6:
		return 123.0000009, "123.000001"
	case 7:
		return 123.00000009, "123.0000001"
	case 8:
		return 123.000000009, "123.00000001"
	case 9:
		return 123.0000000009, "123.000000001"
	case 10:
		return 123.00000000009, "123.0000000001"
	case 11:
		return 123.000000000009, "123.00000000001"
	case 12:
		return 123.0000000000009, "123.000000000001"
	case 13:
		return 123.00000000000009, "123.0000000000001"
	case 14:
		return 123.000000000000009, "123.00000000000001"
	case 15:
		return 123.0000000000000009, "123.000000000000001"
	default:
		return 123 + 1e-16, "123.0000000000000000"
	}
}
